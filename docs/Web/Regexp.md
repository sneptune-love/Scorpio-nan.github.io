#### 正则表达式字符匹配
> 正则表达式是匹配模式, 要么匹配字符, 要么匹配位置;


##### 模糊匹配
如果正则表达式只有精确匹配是没有什么意义的, 比如 `/hello/`, 也只能匹配字符串中的 `hello` 字符串;

正则表达式之所以强大, 是因为它的模糊匹配;

###### 1.横向模糊匹配
横向模糊匹配指的是, 一个正则表达式可匹配的字符串长度是不是固定的, 可以是多种情况;

其实现的方式是使用量词, 比如  `{m, n}` , 表示连续出现最少 `m` 次, 最多 `n` 次;

比如正则表达式 `/ab{2,5}c/` 表示匹配这样的一个字符串: 第一个字母是 `a` , 接下来是 `2 - 5` 个字母 `b`, 最后字符是 `c`;

`````javascript
var reg = /ab{2,5}c/g;
var str = 'abc abbc abbbc abbbbc abbbbbc abbbbbbc';
console.log(str.match(reg));
// => ["abbc", "abbbc", "abbbbc", "abbbbbc"]
`````

`g ` 是正则的一个修饰符. 表示全局匹配, 即, 在目标字符串中按顺序找到满足匹配模式的所有串, 强调的是 "所有", 而不只是  "第一个" . `g ` 是单词 `global ` 的首字母;

###### 2.纵向模糊匹配
纵向模糊匹配指的是一个正则匹配的字符串, 具体到某一位字符的时候, 它可以不是某一个确定的字符, 可以有多种可能;

其实现的方式是使用字符组, 比如 `[abc]` , 表示改字符可以是 `a ` , `b` , `c` 中的任何一个;

比如 `/a[123]b/`, 可以匹配下面三种字符串: `a1b` , `a2b` , `a3b`;

`````javascript
var reg = /a[123]b/g;   
var str = 'a0b a1b a2b a3b a4b';
console.log(str.match(reg));
// => ["a1b", "a2b", "a3b"];
`````

##### 字符组
需要强调的是, 随叫做字符组 (字符类), 但只是其中一个字符;

比如 `[abc]` , 表示匹配一个字符, 它可以是 `a` , `b` , `c` 其中之一;

###### 范围表示法
如果字符组里面的字符特别多的话, 可以使用范围表示法;

比如 `[123456abcdeFGHIJK]`, 可以写成 `[1-6a-eF-K]`, 用连字符 `-` 来省略和简写;

因为连字符有特殊用途, 那么要匹配 `a` , `-` , `z` , 这三者中的任一字符, 该怎么做呢?

不能写成 `[a-z] `, 因为其表示小写字符中的任意一个;

可以写成如下方式: `[-az]`, 或者是 `[az-]` 或 `[a\-z]`.

要么放在开头, 要么放在结尾, 要么转义, 总之不要让引擎认为是范围表示法就行了;

###### 排除字符组
纵向模糊匹配, 还有一种情形就是, 某位字符可以是任意字符, 但就是不能是 `a` , `b` , `c`;

此时就是排除字符组 (反义字符) 的概念, 例如 `[^abc]`, 表示的是除 `a` , `b` , `c` 之外的任意字符, 字符组的第一位放 `^` 表示取反;

###### 









